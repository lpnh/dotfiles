// https://github.com/YaLTeR/niri/wiki/Configuration:-Animations

animations {
    window-open {
        duration-ms 250
        curve "linear"

        custom-shader r"
            // Example: fill the current geometry with a solid vertical gradient and
            // gradually make opaque.
            vec4 solid_gradient(vec3 coords_geo, vec3 size_geo) {
                vec4 color = vec4(0.0);

                // Paint only the area inside the current geometry.
                if (0.0 <= coords_geo.x && coords_geo.x <= 1.0
                        && 0.0 <= coords_geo.y && coords_geo.y <= 1.0)
                {
                    vec4 from = vec4(1.0, 0.0, 0.0, 1.0);
                    vec4 to = vec4(0.0, 1.0, 0.0, 1.0);
                    color = mix(from, to, coords_geo.y);
                }

                // Make it opaque.
                color *= niri_clamped_progress;

                return color;
            }

            // Example: gradually scale up and make opaque, equivalent to the default
            // opening animation.
            vec4 default_open(vec3 coords_geo, vec3 size_geo) {
                // Scale up the window.
                float scale = max(0.0, (niri_progress / 2.0 + 0.5));
                coords_geo = vec3((coords_geo.xy - vec2(0.5)) / scale + vec2(0.5), 1.0);

                // Get color from the window texture.
                vec3 coords_tex = niri_geo_to_tex * coords_geo;
                vec4 color = texture2D(niri_tex, coords_tex.st);

                // Make the window opaque.
                color *= niri_clamped_progress;

                return color;
            }

            // Example: show the window as an expanding circle.
            // Recommended setting: duration-ms 250
            vec4 expanding_circle(vec3 coords_geo, vec3 size_geo) {
                vec3 coords_tex = niri_geo_to_tex * coords_geo;
                vec4 color = texture2D(niri_tex, coords_tex.st);

                vec2 coords = (coords_geo.xy - vec2(0.5, 0.5)) * size_geo.xy * 2.0;
                coords = coords / length(size_geo.xy);
                float p = niri_clamped_progress;
                if (p * p <= dot(coords, coords))
                    color = vec4(0.0);

                return color;
            }

            // This is the function that you must define.
            vec4 open_color(vec3 coords_geo, vec3 size_geo) {
                // You can pick one of the example functions or write your own.
                return default_open(coords_geo, size_geo);
            }
        "
    }

    window-close {
        // off
        duration-ms 250
        curve "ease-out-quad"

        custom-shader r"
            // Example: fill the current geometry with a solid vertical gradient and
            // gradually make transparent.
            vec4 solid_gradient(vec3 coords_geo, vec3 size_geo) {
                vec4 color = vec4(0.0);

                // Paint only the area inside the current geometry.
                if (0.0 <= coords_geo.x && coords_geo.x <= 1.0
                    && 0.0 <= coords_geo.y && coords_geo.y <= 1.0)
                {
                    vec4 from = vec4(1.0, 0.0, 0.0, 1.0);
                    vec4 to = vec4(0.0, 1.0, 0.0, 1.0);
                    color = mix(from, to, coords_geo.y);
                }

                // Make it transparent.
                color *= (1.0 - niri_clamped_progress);

                return color;
            }

            // Example: gradually scale down and make transparent, equivalent to the
            // default closing animation.
            vec4 default_close(vec3 coords_geo, vec3 size_geo) {
                // Scale down the window.
                float scale = max(0.0, ((1.0 - niri_clamped_progress) / 5.0 + 0.8));
                coords_geo = vec3((coords_geo.xy - vec2(0.5)) / scale + vec2(0.5), 1.0);

                // Get color from the window texture.
                vec3 coords_tex = niri_geo_to_tex * coords_geo;
                vec4 color = texture2D(niri_tex, coords_tex.st);

                // Make the window transparent.
                color *= (1.0 - niri_clamped_progress);

                return color;
            }

            // Example: make the window 'fall down' with slight rotation.
            vec4 fall_and_rotate(vec3 coords_geo, vec3 size_geo) {
                // For this shader, set animation curve to linear for best results.

                // Simulate an accelerated fall: square the (linear) progress.
                float progress = niri_clamped_progress * niri_clamped_progress;

                // Get our rotation pivot point coordinates at the bottom center of the window.
                vec2 coords = (coords_geo.xy - vec2(0.5, 1.0)) * size_geo.xy;

                // Move the window down to simulate a fall.
                coords.y -= progress * 200.0;

                // Randomize rotation direction and maximum angle.
                float random = (niri_random_seed - 0.5) / 2.0;
                random = sign(random) - random;
                float max_angle = 0.05 * random;

                // Rotate the window around our pivot point.
                float angle = progress * max_angle;
                mat2 rotate = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
                coords = rotate * coords;

                // Transform the coordinates back.
                coords_geo = vec3(coords / size_geo.xy + vec2(0.5, 1.0), 1.0);

                // Sample the window texture.
                vec3 coords_tex = niri_geo_to_tex * coords_geo;
                vec4 color = texture2D(niri_tex, coords_tex.st);

                // Multiply by alpha to fade out.
                return color * (1.0 - niri_clamped_progress);
            }

            vec4 close_color(vec3 coords_geo, vec3 size_geo) {
                // You can pick one of the example functions or write your own.
                return default_close(coords_geo, size_geo);
            }
        "
    }

    horizontal-view-movement {
        // off
        duration-ms 250
        curve "ease-out-quad"
    }

    window-movement {
        // off
        duration-ms 250
        curve "ease-out-quad"
    }

    window-resize {
        off
        duration-ms 250
        curve "ease-out-quad"

        custom-shader r"
            // Example: fill the current geometry with a solid vertical gradient.
            vec4 solid_gradient(vec3 coords_curr_geo, vec3 size_curr_geo) {
                vec3 coords = coords_curr_geo;
                vec4 color = vec4(0.0);

                // Paint only the area inside the current geometry.
                if (0.0 <= coords.x && coords.x <= 1.0
                        && 0.0 <= coords.y && coords.y <= 1.0)
                {
                    vec4 from = vec4(1.0, 0.0, 0.0, 1.0);
                    vec4 to = vec4(0.0, 1.0, 0.0, 1.0);
                    color = mix(from, to, coords.y);
                }

                return color;
            }

            // Example: crossfade between previous and next texture, stretched to the
            // current geometry.
            vec4 crossfade(vec3 coords_curr_geo, vec3 size_curr_geo) {
                // Convert coordinates into the texture space for sampling.
                vec3 coords_tex_prev = niri_geo_to_tex_prev * coords_curr_geo;
                vec4 color_prev = texture2D(niri_tex_prev, coords_tex_prev.st);

                // Convert coordinates into the texture space for sampling.
                vec3 coords_tex_next = niri_geo_to_tex_next * coords_curr_geo;
                vec4 color_next = texture2D(niri_tex_next, coords_tex_next.st);

                vec4 color = mix(color_prev, color_next, niri_clamped_progress);
                return color;
            }

            // Example: next texture, stretched to the current geometry.
            vec4 stretch_next(vec3 coords_curr_geo, vec3 size_curr_geo) {
                vec3 coords_tex_next = niri_geo_to_tex_next * coords_curr_geo;
                vec4 color = texture2D(niri_tex_next, coords_tex_next.st);
                return color;
            }

            // Example: next texture, stretched to the current geometry if smaller, and
            // cropped if bigger.
            vec4 stretch_or_crop_next(vec3 coords_curr_geo, vec3 size_curr_geo) {
                vec3 coords_next_geo = niri_curr_geo_to_next_geo * coords_curr_geo;

                vec3 coords_stretch = niri_geo_to_tex_next * coords_curr_geo;
                vec3 coords_crop = niri_geo_to_tex_next * coords_next_geo;

                // We can crop if the current window size is smaller than the next window
                // size. One way to tell is by comparing to 1.0 the X and Y scaling
                // coefficients in the current-to-next transformation matrix.
                bool can_crop_by_x = niri_curr_geo_to_next_geo[0][0] <= 1.0;
                bool can_crop_by_y = niri_curr_geo_to_next_geo[1][1] <= 1.0;

                vec3 coords = coords_stretch;
                if (can_crop_by_x)
                    coords.x = coords_crop.x;
                if (can_crop_by_y)
                    coords.y = coords_crop.y;

                vec4 color = texture2D(niri_tex_next, coords.st);

                // However, when we crop, we also want to crop out anything outside the
                // current geometry. This is because the area of the shader is unspecified
                // and usually bigger than the current geometry, so if we don't fill pixels
                // outside with transparency, the texture will leak out.
                //
                // When stretching, this is not an issue because the area outside will
                // correspond to client-side decoration shadows, which are already supposed
                // to be outside.
                if (can_crop_by_x && (coords_curr_geo.x < 0.0 || 1.0 < coords_curr_geo.x))
                    color = vec4(0.0);
                if (can_crop_by_y && (coords_curr_geo.y < 0.0 || 1.0 < coords_curr_geo.y))
                    color = vec4(0.0);

                return color;
            }

            // Example: cropped next texture if it's bigger than the current geometry, and
            // crossfade between previous and next texture otherwise.
            vec4 crossfade_or_crop_next(vec3 coords_curr_geo, vec3 size_curr_geo) {
                vec3 coords_next_geo = niri_curr_geo_to_next_geo * coords_curr_geo;
                vec3 coords_prev_geo = niri_curr_geo_to_prev_geo * coords_curr_geo;

                vec3 coords_crop = niri_geo_to_tex_next * coords_next_geo;
                vec3 coords_stretch = niri_geo_to_tex_next * coords_curr_geo;
                vec3 coords_stretch_prev = niri_geo_to_tex_prev * coords_curr_geo;

                // We can crop if the current window size is smaller than the next window
                // size. One way to tell is by comparing to 1.0 the X and Y scaling
                // coefficients in the current-to-next transformation matrix.
                bool can_crop_by_x = niri_curr_geo_to_next_geo[0][0] <= 1.0;
                bool can_crop_by_y = niri_curr_geo_to_next_geo[1][1] <= 1.0;
                bool crop = can_crop_by_x && can_crop_by_y;

                vec4 color;

                if (crop) {
                    // However, when we crop, we also want to crop out anything outside the
                    // current geometry. This is because the area of the shader is unspecified
                    // and usually bigger than the current geometry, so if we don't fill pixels
                    // outside with transparency, the texture will leak out.
                    //
                    // When crossfading, this is not an issue because the area outside will
                    // correspond to client-side decoration shadows, which are already supposed
                    // to be outside.
                    if (coords_curr_geo.x < 0.0 || 1.0 < coords_curr_geo.x ||
                        coords_curr_geo.y < 0.0 || 1.0 < coords_curr_geo.y) {
                        color = vec4(0.0);
                    } else {
                        color = texture2D(niri_tex_next, coords_crop.st);
                    }
                } else {
                    // If we can't crop, then crossfade.
                    color = texture2D(niri_tex_next, coords_stretch.st);
                    vec4 color_prev = texture2D(niri_tex_prev, coords_stretch_prev.st);
                    color = mix(color_prev, color, niri_clamped_progress);
                }

                return color;
            }

            vec4 resize_color(vec3 coords_curr_geo, vec3 size_curr_geo) {
                // You can pick one of the example functions or write your own.
                return crossfade_or_crop_next(coords_curr_geo, size_curr_geo);
            }
        "
    }

    config-notification-open-close {
        off
        // spring damping-ratio=0.6 stiffness=1000 epsilon=0.001
    }
}
